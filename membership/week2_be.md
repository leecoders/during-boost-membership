### http

#### HTTP의 필요성

- 컴퓨터 네트워크 : 어떤 object들이 연결(connect)되어 있는 것
- 인터넷 : 네트워크들이 연결
- 인터넷의 관리 주체는 없다.
  - 각 국가의 망을 각자 관리할 뿐
- 대부분의 웹 서비스는 HTTP를 통해 제공된다.
  - HTTP의 동작 방식을 이해하는 것이 백엔드 개발에 필수적이다.

#### 추상 누출의 원리

- 추상화된 계층의 아래 계층을 학습에 의해 기반 기술을 이해하지 못하면 실패하는 경우가 많다.

#### 웹

- 웹의 3요소 : HTTP(통신 프로토콜), HTML, URL(HTML을 요청)
- 자바스크립트 : HTML를 동적으로 제어하기 위해 탄생(DOM을 제어)
  - DOM : document를 object로 제어하기 위한 모델

#### HTTP

- TCP와 UDP를 사용하며, 80번 포트를 사용한다.
- OSI 7계층에 대해 이해해야 한다.
  - TCP/IP 4계층, OSI 7계층 [링크](https://goitgo.tistory.com/25)
    ![TCP/IP 4계층, OSI 7계층](https://t1.daumcdn.net/cfile/tistory/261CC03358E1B73D32)
  - TCP 프로토콜 : reliable - 보내는 쪽과 받는 쪽이 같다는 것이 보장됨
  - IP 프로토콜 : unreliable - 보장되지 않음
  - 책 [그림으로 보는 TCP/IP]

#### 주요 개념

- 클라이언트: 주로 웹 브라우저로 항상 요청만 한다.
- 서버: 클라이언트의 요청에 대해 적당한 문서를 제공해 준다.
- 프록시: 클라이언트와 서버 사이에 존재. 캐싱, 필터링, 로드 밸런싱, 인증, 로깅 등의 다양한 기능을 수행

#### HTTP의 특징

- 간단
- 확장 가능
- 상태가 없다 = stateless
- 세션은 존재 = 쿠키를 이용해
- HTTP1 --> HTTP/1.1 --> HTTP/2 로 발전

#### 브라우저의 동작

- 최초 응답시 HTML을 가져옴
- HTML에서 CSS, js, 이미지에 대한 링크 정보를 추출
- 추출한 정보의 URL을 이용 새로운 요청을 보냄
- 모든 웹 자원을 받아와서 렌더링 시작
- 1.1 은 파이프라인, 2.0은 병렬처리로 성능개선

#### TCP의 3-way Handshake

- 끊을 때는 4번

#### net

- socket
- 4인용 포커게임
  - 클라이언트
    - 소켓 생성 - 서버 접속 - 인증
    - 서버 - 4개의 소켓
      - 사용자 로그인 - DB에서 데이터를 읽어서 인증
    - 이후 사용자 식별 / 메시지 응답 어떻게?
  - 서버
    - 클라이언트당 소켓 유지
    - 최초 로그인시 데이터베이스에서 정보를 읽어와서 인증
    - 이후 정상적으로 게임이 동작하려면?
    - 명령이 왔을 때 어떻게 사용자를 식별하는가?
      - 클라이언트가 자기가 누구인지 정보를 담아서 보낸다. -> 보안에 매우 취약
      - 소켓에 있는 ip로 식별한다.
      - 정답 : 소켓은 식별을 할 필요가 없다.. -> 어차피 1:1 연결 후 끊기지 않으니까 해당 소켓에서 오는 명령은 전부 해당 사용자로부터 온 것
  - 세션 테이블

#### 쿠키

- 저장은 클라이언트에서 하고, 값 저장의 요청은 서버에서 한다.
- 삭제는 쿠키의 만료 시간(또한 서버의 요청에 의해 지정됨) -> 만료 시간을 현재 시간으로 지정해버림
- 변경은 같은 키값에 다른 값을 넣음
- 쿠키에 ID를 저장하면 안된다. 그래서 쿠키에는 session-id만 보낸다.
  - 보안을 위해 session-id는 굉장히 큰 값(uuid)을 사용한다.
- 브라우저 껐다 켜도 남아있는 이유는 파일로 저장되기 때문이다.

### Node.js

- Node.js는 JS 런타임으로 빠르고 강력하다.

#### 배경지식(꼭 찾아서 공부하기)

- 웹 브라우져의 동작 원리
- Chrome V8 엔진(엄청난 성능 개선)

#### Node.js 공식 문서

- [공식 문서](https://nodejs.org/dist/latest-v10.x/docs/api/) 반드시 읽어보기
- Node.js는 비동기 논블로킹 방식
  - 동기 vs 비동기
  - 블로킹 vs 논블로킹
  - 4가지 경우의 수가 있지만 [동기, 블로킹]과 [비동기, 논블로킹]이 대표적이다.
- 대부분의 논블로킹 방식은 이벤트가 관여한다.

#### net (확장->) http (확장->) express

#### 미들웨어의 동작 방식을 이해하는 것이 중요하다.

- 순서가 상당히 중요하다.
- `next()`를 호출해야 다음으로 넘어간다. 아니면 계속 res를 기다린다.
- res를 send하면 응답하고 코드 실행은 멈춘다. -> res 없이 next, next, ... 이면 코드가 끝까지 실행되어 에러 처리까지 작동한다.
- `next()`에 어떠한 인자를 넣으면 바로 에러 처리 코드(error handler)로 이동한다. 중간 부분은 건너 뛰어버림
- npm nodemon은 소스 수정시 자동으로 서버를 재시작해준다.
- middleware로 전달하는 콜백은 여러 개 전달할 수 있다(?) -> 중복 줄이려고
  **결론 : express에서는 middleware가 제일 중요하다!**

#### npm express-generator 사용

#### jade -> pug로 바뀜

## 알게된 내용

### Fetch API

- Request나 Response와 같은 HTTP의 파이프라인을 구성하는 요소를 조작하는것이 가능하다.

### 로그인 - 쿠키, 세션을 이용한 방식

![쿠키와세션을이용한로그인](https://t1.daumcdn.net/cfile/tistory/994BEA345B53368401)

- 장점과 단점
  - 장점
    1. 세션/쿠키 방식은 기본적으로 쿠키를 매개로 인증을 거칩니다. 여기서 쿠키는 세션 저장소에 담긴 유저 정보를 얻기 위한 열쇠라고 보시면 됩니다. 따라서 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 갖고있지 않습니다(중요 정보는 서버 세션에) 이는 위의 계정정보를 담아 인증을 거치는 것보단 안전해 보입니다.
    2. 사용자 A는 1번, 사용자 B는 2번 이런식으로 고유의 ID값을 발급받게 됩니다. 그렇게 되면 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이할 것입니다.
  - 단점
    1. 장점 1에서 쿠키를 탈취당하더라도 안전할 수 있다고 언급했습니다. 그러나 문제가 하나 있습니다. 만일 A 사용자의 HTTP 요청을 B 사용자(해커)가 가로챘다면 그 안에 들어있는 쿠키도 충분히 훔칠 수 있습니다. 그리고 B 사용자는 그 훔친 쿠키를 이용해 HTTP 요청을 보내면 서버의 세션저장소에서는 A 사용자로 오인해 정보를 잘못 뿌려주게 되겠죠(**세션 하이재킹 공격**이라고 합니다)

> [참고](https://tansfil.tistory.com/58)

### DB - SQLite

- 자료형
  - NULL: 널값
  - INTEGER: 1,2,3,4,6,8bytes의 정수값
    (자동증가 시킬 경우 INTEGER PRIMARY KEY AUTOINCREMENT 로 표기)
  - REAL: 8bytes의 부동소수점값
  - TEXT: UTF-8, UTF-16BE, UTF-16LE인코딩의 문자열
  - BLOB: 입력된 그대로 저장, 바이너리 파일 등

### express.json() http로 json string 받으면 알아서 타입별로 파싱해준다. 좋다.

### SQLite의 select 동작을 위한 all() 함수는 Promise를 반환한다.

- async/await, then, resolve 등의 조합으로 Promise 패턴으로 비동기 처리를 고민해보자.
- 지금은 better-sqlite3를 통해 구현한 상태
  - 비동기 고민

### 서버가 꺼졌다 켜졌을 때 세션을 유지해야 하는가에 대한 고민이 필요하다

- 세션을 DB 또는 express-session의 세션을 파일로 저장하는 옵션을 통해 세션을 유지시킬 수 있다.
- 굳이 저장 해야되는가?
  - 만약 서버가 다운되어 세션이 모두 사라진다면 모든 사용자가 로그아웃되는 문제가 있다.

### 400에러 (Bad request)

- 전송하는 request에 문제가 있을 때 발생
- 데이터 타입을 확인할 것

### res.cookie()로 쿠키를 저장할 때 이미 존재하는 key에 value를 저장하면 덮어 씌워진다.

- 없으면 새로 만들어짐
- 지정된 expires 이후에 사라짐

### HttpOnly와 document.cookie

- document.cookie로 cookie를 확인할 수 있다.
- 하지만 HttpOnly 속성이 걸려있으면 쿠키를 중간에 가로채는 것을 막기 위해 서버와의 http 통신으로만 확인 가능하다.
