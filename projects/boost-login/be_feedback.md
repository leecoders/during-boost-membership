## 마스터 클래스

### http

#### HTTP의 필요성

- 컴퓨터 네트워크 : 어떤 object들이 연결(connect)되어 있는 것
- 인터넷 : 네트워크들이 연결
- 인터넷의 관리 주체는 없다.
  - 각 국가의 망을 각자 관리할 뿐
- 대부분의 웹 서비스는 HTTP를 통해 제공된다.
  - HTTP의 동작 방식을 이해하는 것이 백엔드 개발에 필수적이다.

#### 추상 누출의 원리

- 추상화된 계층의 아래 계층을 학습에 의해 기반 기술을 이해하지 못하면 실패하는 경우가 많다.

#### 웹

- 웹의 3요소 : HTTP(통신 프로토콜), HTML, URL(HTML을 요청)
- 자바스크립트 : HTML를 동적으로 제어하기 위해 탄생(DOM을 제어)
  - DOM : document를 object로 제어하기 위한 모델

#### HTTP

- TCP와 UDP를 사용하며, 80번 포트를 사용한다.
- OSI 7계층에 대해 이해해야 한다.
  - TCP/IP 4계층, OSI 7계층 [링크](https://goitgo.tistory.com/25)
    ![TCP/IP 4계층, OSI 7계층](https://t1.daumcdn.net/cfile/tistory/261CC03358E1B73D32)
  - TCP 프로토콜 : reliable - 보내는 쪽과 받는 쪽이 같다는 것이 보장됨
  - IP 프로토콜 : unreliable - 보장되지 않음
  - 책 [그림으로 보는 TCP/IP]

#### 주요 개념

- 클라이언트: 주로 웹 브라우저로 항상 요청만 한다.
- 서버: 클라이언트의 요청에 대해 적당한 문서를 제공해 준다.
- 프록시: 클라이언트와 서버 사이에 존재. 캐싱, 필터링, 로드 밸런싱, 인증, 로깅 등의 다양한 기능을 수행

#### HTTP의 특징

- 간단
- 확장 가능
- 상태가 없다 = stateless
- 세션은 존재 = 쿠키를 이용해
- HTTP1 --> HTTP/1.1 --> HTTP/2 로 발전

#### 브라우저의 동작

- 최초 응답시 HTML을 가져옴
- HTML에서 CSS, js, 이미지에 대한 링크 정보를 추출
- 추출한 정보의 URL을 이용 새로운 요청을 보냄
- 모든 웹 자원을 받아와서 렌더링 시작
- 1.1 은 파이프라인, 2.0은 병렬처리로 성능개선

#### TCP의 3-way Handshake

- 끊을 때는 4번

#### net

- socket
- 4인용 포커게임
  - 클라이언트
    - 소켓 생성 - 서버 접속 - 인증
    - 서버 - 4개의 소켓
      - 사용자 로그인 - DB에서 데이터를 읽어서 인증
    - 이후 사용자 식별 / 메시지 응답 어떻게?
  - 서버
    - 클라이언트당 소켓 유지
    - 최초 로그인시 데이터베이스에서 정보를 읽어와서 인증
    - 이후 정상적으로 게임이 동작하려면?
    - 명령이 왔을 때 어떻게 사용자를 식별하는가?
      - 클라이언트가 자기가 누구인지 정보를 담아서 보낸다. -> 보안에 매우 취약
      - 소켓에 있는 ip로 식별한다.
      - 정답 : 소켓은 식별을 할 필요가 없다.. -> 어차피 1:1 연결 후 끊기지 않으니까 해당 소켓에서 오는 명령은 전부 해당 사용자로부터 온 것
  - 세션 테이블

#### 쿠키

- 저장은 클라이언트에서 하고, 값 저장의 요청은 서버에서 한다.
- 삭제는 쿠키의 만료 시간(또한 서버의 요청에 의해 지정됨) -> 만료 시간을 현재 시간으로 지정해버림
- 변경은 같은 키값에 다른 값을 넣음
- 쿠키에 ID를 저장하면 안된다. 그래서 쿠키에는 session-id만 보낸다.
  - 보안을 위해 session-id는 굉장히 큰 값(uuid)을 사용한다.
- 브라우저 껐다 켜도 남아있는 이유는 파일로 저장되기 때문이다.

### Node.js

- Node.js는 JS 런타임으로 빠르고 강력하다.

#### 배경지식(꼭 찾아서 공부하기)

- 웹 브라우져의 동작 원리
- Chrome V8 엔진(엄청난 성능 개선)

#### Node.js 공식 문서

- [공식 문서](https://nodejs.org/dist/latest-v10.x/docs/api/) 반드시 읽어보기
- Node.js는 비동기 논블로킹 방식
  - 동기 vs 비동기
  - 블로킹 vs 논블로킹
  - 4가지 경우의 수가 있지만 [동기, 블로킹]과 [비동기, 논블로킹]이 대표적이다.
- 대부분의 논블로킹 방식은 이벤트가 관여한다.

#### net (확장->) http (확장->) express

#### 미들웨어의 동작 방식을 이해하는 것이 중요하다.

- 순서가 상당히 중요하다.
- `next()`를 호출해야 다음으로 넘어간다. 아니면 계속 res를 기다린다.
- res를 send하면 응답하고 코드 실행은 멈춘다. -> res 없이 next, next, ... 이면 코드가 끝까지 실행되어 에러 처리까지 작동한다.
- `next()`에 어떠한 인자를 넣으면 바로 에러 처리 코드(error handler)로 이동한다. 중간 부분은 건너 뛰어버림
- npm nodemon은 소스 수정시 자동으로 서버를 재시작해준다.
- middleware로 전달하는 콜백은 여러 개 전달할 수 있다(?) -> 중복 줄이려고
  **결론 : express에서는 middleware가 제일 중요하다!**

#### npm express-generator 사용

#### jade -> pug로 바뀜

## 알게된 내용

### Fetch API

- Request나 Response와 같은 HTTP의 파이프라인을 구성하는 요소를 조작하는것이 가능하다.

### 로그인 - 쿠키, 세션을 이용한 방식

![쿠키와세션을이용한로그인](https://t1.daumcdn.net/cfile/tistory/994BEA345B53368401)

- 장점과 단점
  - 장점
    1. 세션/쿠키 방식은 기본적으로 쿠키를 매개로 인증을 거칩니다. 여기서 쿠키는 세션 저장소에 담긴 유저 정보를 얻기 위한 열쇠라고 보시면 됩니다. 따라서 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 갖고있지 않습니다(중요 정보는 서버 세션에) 이는 위의 계정정보를 담아 인증을 거치는 것보단 안전해 보입니다.
    2. 사용자 A는 1번, 사용자 B는 2번 이런식으로 고유의 ID값을 발급받게 됩니다. 그렇게 되면 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이할 것입니다.
  - 단점
    1. 장점 1에서 쿠키를 탈취당하더라도 안전할 수 있다고 언급했습니다. 그러나 문제가 하나 있습니다. 만일 A 사용자의 HTTP 요청을 B 사용자(해커)가 가로챘다면 그 안에 들어있는 쿠키도 충분히 훔칠 수 있습니다. 그리고 B 사용자는 그 훔친 쿠키를 이용해 HTTP 요청을 보내면 서버의 세션저장소에서는 A 사용자로 오인해 정보를 잘못 뿌려주게 되겠죠(**세션 하이재킹 공격**이라고 합니다)

> [참고](https://tansfil.tistory.com/58)

### DB - SQLite

- 자료형
  - NULL: 널값
  - INTEGER: 1,2,3,4,6,8bytes의 정수값
    (자동증가 시킬 경우 INTEGER PRIMARY KEY AUTOINCREMENT 로 표기)
  - REAL: 8bytes의 부동소수점값
  - TEXT: UTF-8, UTF-16BE, UTF-16LE인코딩의 문자열
  - BLOB: 입력된 그대로 저장, 바이너리 파일 등

### express.json() http로 json string 받으면 알아서 타입별로 파싱해준다. 좋다.

### SQLite의 select 동작을 위한 all() 함수는 Promise를 반환한다.

- async/await, then, resolve 등의 조합으로 Promise 패턴으로 비동기 처리를 고민해보자.
- 지금은 better-sqlite3를 통해 구현한 상태
  - 비동기 고민

### 서버가 꺼졌다 켜졌을 때 세션을 유지해야 하는가에 대한 고민이 필요하다

- 세션을 DB 또는 express-session의 세션을 파일로 저장하는 옵션을 통해 세션을 유지시킬 수 있다.
- 굳이 저장 해야되는가?
  - 만약 서버가 다운되어 세션이 모두 사라진다면 모든 사용자가 로그아웃되는 문제가 있다.

### 400에러 (Bad request)

- 전송하는 request에 문제가 있을 때 발생
- 데이터 타입을 확인할 것

### res.cookie()로 쿠키를 저장할 때 이미 존재하는 key에 value를 저장하면 덮어 씌워진다.

- 없으면 새로 만들어짐
- 지정된 expires 이후에 사라짐

### HttpOnly와 document.cookie

- document.cookie로 cookie를 확인할 수 있다.
- 하지만 HttpOnly 속성이 걸려있으면 쿠키를 중간에 가로채는 것을 막기 위해 서버와의 http 통신으로만 확인 가능하다.

### 클릭시 마우스 이벤트 순서

1. mousedown
2. mouseup
3. click

- 관련 이슈
  - mouseup 이벤트에 레이어 바깥을 클릭하면 레이어가 꺼지도록 함
  - click 이벤트에 레이어가 있으면 꺼지고, 없으면 켜지도록 동작하도록 함 -> 동작 안함
  - 레이어가 켜져있을 때 버튼 클릭
    - mouseup 이벤트(레이어 범위 넘었기 때문에 레이어 꺼짐)
    - click 이벤트(레이어 없는 것으로 알고 다시 레이어 만들어버림)
  - outside에 의해 버튼이 가려지도록 했을 때는 문제가 안되었으나 메인화면의 header 부분이 화면 맨 위에 항상 떠있도록(outside에 의해 가려지지 않도록) 했을 때는 버튼이 이벤트를 받아버려 문제가 됨
  - 해결
    - mousedown(없으면o 있으면x) -> mouseup(레이어 꺼짐) -> click(o이면 생성)
    - 마지막 click 이벤트 발생시 mouseup에 관계 없이(상태 변화 무시해버림) mousedown에서 결정된 켜야할지 꺼야할지 여부만 체크

### express-session은 어떻게 동작하는지, 세션이 어떻게 동작해야 하는 것이 맞는지에 대한 고민

- 쿠키와 세션에 싱크가 맞는 expires 시간이 있을텐데 서버에서는 세션을 어떻게 관리하는지

1. setInterval 처럼 단위 시간 동안 계속 확인하면서 만료 시간이 되었으면 폐기시키는 방법
2. 쿠키에서는 만료 시간이 되어 폐기되었으나 서버에서는 세션을 확인하지 않아 시간만 지났고 폐기되지 않은 상태(싱크가 안 맞는 것처럼 혼란 가능성) -> 요청이 왔을 때마다 서버에서 세션을 확인하여 만료된 세션을 폐기시키는 방법

### 자바스크립트로 HTML 엘리먼트 객체에 class 이름 추가, 삭제하기

- ele.classList.add()
- ele.classList.remove()

### res.send(), res.render() 등의 응답 메서드 다음에 있는 코드가 실행된다.

- 응답 메서드 사용하면 라우팅 함수가 종료되는 줄 알았는데 아니었다. [참고](https://stackoverflow.com/questions/16180502/why-can-i-execute-code-after-res-send)
  - 하지만 res를 통한 응답 메서드 호출 뒤에는 res를 통해 다른 작업을 할 수는 없다.
- 라우터 미들웨어 다음에 있는 미들웨어는??

### 미들웨어 또는 라우터에서 `res.redirect()`를 호출하면 지정된 경로로 다시 요청이 시작되어 1번 미들웨어부터 재실행된다.

- 그런데 redirect() -> render()를 한다고 강제로 사용자 브라우저가 리로드되지는 않는다..
  - 당연히 안되지 url은 똑같이 하고 body만 바뀌는 SPA 구조를 갖고 있으니까..
  - 어쩔 수 없이 window에 hashchangh 이벤트를 달아주고 url마다 지정된 함수를 호출해서 body를 바꾸는 구조를 다시 짜야할 것 같다.

### 사용자 정의 미들웨어 추가할 때는 파라미터를 꼭 지정해야 한다.

- req, res, next가 필요

```javascript
app.use((req, res, next) => {
  next();
});
```

### fetch는 같은 페이지에서 reload되지 않고 서버와 통신하기 위해 사용되는 함수이다.

- form같은 경우에는 자연스럽게 서버로 form이 전송되는 동시에 reload되며 서버에서 받은 url이 실행되도록 할 수 있으나 SPA에서는 서버에서 능동적으로 사용자의 url을 바꿀 수는 없다.
  - 그러므로 서버에서 url을 바꿔야 하는 응답(?)이 오면 프론트엔드 코드에서 페이지를 수정하는 방법밖에는 없다.
  - 그런데 fetch는 Promise를 반환해버리니까 `new Error()`로 에러를 발생시켜도 `try/catch`로 받을 수 없다.. 어떤 값이 오는지에 따라 적절이 첫 페이지로 보내는 방법밖에 없을 듯하다. (비동기는 받는 쪽에서 try/catch하면 못 걸러낸다고 함..)

## 2주차 마스터 클래스(day5)

### 코드 리뷰

- 리뷰 없는 회사에서 성장하기 쉽지 않다.
- 코드 리뷰 가이드 : [링크](https://soojin.ro/review/reviewer)
  - 주석에 대해
    - 유용한 주석은 코드가 어떤 일을 하는지가 아니라 왜 존재하는지를 담고 있다.
  - CL(PR)이 완벽하지 않더라도 전체적인 코드 품질을 증가시키는 상태에 도달했다면 리뷰어(머지하는 사람)는 해당 CL을 승인하는 방향으로 생각한다.
- 스타일 가이드
  - 주의: 코드 품질을 악화시키는(더러운 코드 - if/else 도배) CL을 승인하는 행위는 어떠한 경우에도 정당화될 수 없다. 오직 긴급상황(hotfix - 장애가 발생한 경우)일 때만 허용된다.
    - hotfix는 더럽게 해결한 뒤 내 브랜치로 가져와서 깔끔하게 리팩토링한다. (브랜치 관리도 rebase로 정리하면 노선도처럼 더럽지 않을 수 있지만 지키는 회사는 별로 없다.)
  - 언제나 기술적인 사실을 개인적인(사실은 팀장님의..) 견해나 선호도보다 우선시 한다.
  - 회사에는 스타일 가이드가 무조건 있어야 한다. 없으면 무조건 정해야 한다.(보통은 구글, 넷플릭스, js의 경우 에어비앤비 가이드를 따른다.)
    - 가이드가 있다면 무조건 따라야 한다.
    - 정해둔 규칙이 없다면 기존 코드와 일관성을 맞춘다.
  - 리팩토링과 디자인 수정은 별개로 진행한다.
  - 대화 내용은 미래 개발자들을 위해 반드시 댓글로 남긴다.
  - 좋은 git 커밋 메시지
    - [링크](https://meetup.toast.com/posts/106)
    - 제목 : 영문 기준 50자 이내 추천
    - 본문 : 영문 기준 72자 이내 추천
    - 본문?
- 테스트
  - 테스트가 없는 것은 말이 안된다. 무조건 해야 한다.
  - TDD는 옵션이다.
  - 테스트는 복잡도가 올라가는 경우에 꼭 필요하기 때문이다.
  - 코드에 대한 테스트 코드를 짤 수 없어서 원래 코드를 리팩토링한다면 지극히 정상인 경우
- README는 길어지면 분리한다. 되도록 간단히
- 배포
  - 환경변수 관리에 주의할 것(dotenv 등을 사용)
  - 초기화 스크립트를 적절히 사용하자(초기 데이터 넣어서 서버 껐다가 켰을 때 회원가입 없이도 로그인 할 수 있도록)
    - 시간 매우 줄일 수 있다.
- 로그인된 상태에서 로그인 페이지로 간다면?
  - 로그인 상태 유지, 자동 로그아웃
  - 고려할 수 있는 사항
    1. 사용자
    2. 서버 부하 덜한 것
- 비동기 에러처리 원래 힘들다.
- 리뷰 시간은 5일 동안 개발한 코드라면 최소한 하루 정도는 풀타임으로 미리 보고 와야 한다. (리뷰 전)

**마무리**

- 좋은 글을 쓰려면 많이 읽고 많이 써야한다. 좋은 코드를 짜려면 좋은 코드를 많이 읽고 주변 친구들 코드도 많이 읽어야 한다.
  - 나보다 조금만 더 잘하는 사람의 코드를 보고 배우는 것이 가장 좋다.
